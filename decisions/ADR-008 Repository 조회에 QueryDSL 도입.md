# ADR-008 Repository 조회에 QueryDSL 도입
---

## Status
---  
Accepted

## Context
---
우리 서비스에는 다음과 같은 요구사항이 있다.
- 동적 검색 / 필터링 (키워드, 카테고리, 가격 범위, 재고 여부)
- 페이징 및 정렬

**기존 문제**
초기에는 상품 검색 로직을 JPQL @Query로 작성했다.
- 간단한 조건에서는 문제가 없었지만 조건이 점점 늘어나면서 문자열이 길어지고 가독성이 떨어졌다
- 유지보수 과정에서 오타나 잘못된 속성이 있어도 컴파일 타임에 검증되지 않아 런타임 에러가 발생했다

이런 경험을 통해서 JPQL 기반 접근 방식은 유지보수성에 있어서 문제가 있다고 인식하게 되었다

**다른 대안의 한계**
- JPQL 문자열 : 동적 조건 처리 시 문자열 이어 붙이기로 가독성이 떨어짐, 컴파일 타임 검증이 안됨 -> 런타임 에러 발생 위험
- Criteria API : 타입 안정성은 있지만 가독성이 낮음
- Native SQL : 표현력은 좋지만 DB 종속적이고 엔티티/타입 안정성이 없다


## Decision
---
복잡하고 동적인 쿼리 요구사항을 처리하기 위해 QueryDSL을 도입한다

이유는

1. 타입 안정성
    - JPQL 문자열 기반 방식은 잘못된 컬러명, 엔티티명을 작성해도 컴파일 타임 검증이 되지 않아 런타임 에러로 이어질 수 있다
    - QueryDSL은 Q 타입을 통해 컴파일 타임에 오류를 잡을 수 있다

2. 가독성과 유지보수성
    - Criteria API는 가독성이 떨어진다
    - QueryDSL은 동적 조건을 메서드화하여 조건 추가, 수정이 용이하고 코드 구조가 깔끔하다

3. 성능 제어 가능성
    - Native SQL처럼 세밀한 제어가 가능하면서도 엔티티, DTO와 잘 연동된다
    - count 쿼리 분리나 join fetch 등 최적화 전략을 적용하기  유리하다

4. 테스트 용이성
    - 실제 MySQL 환경에서 Testcontainers로 쿼리 결과를 검증할 수 있어 안정적이다



## Consequences
---

**장점**
- 안정성 : 컴파일 타임 검증을 통해서 런타임 에러를 예방할 수 있다
- 유지보수성 : 동적 쿼리 조건을 메서드 단위로 분리해서 가독성이 높아지고 조건 추가와 변경이 쉬워진다
- 테스트 신뢰성: Testcontainers 기반으로 실제 DB 환경에서 QueryDSL 로직을 검증할 수 있어 단순 Mock 테스트보다 신뢰도가 높다

**단점**
- QueryDSL 문법과 패턴을 학습해야해서 러닝커브가 존재한다

**이후 고려사항**
- 단순 CRUD까지 모두 QueryDSL로 작성하면 오히려 코드가 복잡해질 수 있다
- 그래서 복잡한 쿼리문은 QueryDSL로 처리하고 단순 CRUD는 JpaRepository 메서드를 적절하게 병행한다