# ADR-011 : 스케줄링 "생일 포인트 지급" 재시도(Retry) 전략


## Status

Accepted

## Context
- 매일 00:30에 실행되는 스케줄러가 생일자에게 포인트를 지급한다.
- 운영 환경에서는 DB Deadlock, Lock 충돌, Timeout 등 일시적 오류가 발생하거나 예상치 못한 장애로 인해서 지급이 누락되는 상황이 있을 거라고 판단했다.
- 단일 실패가 전체 배치를 롤백시키는 문제와 재시도 과정에서 중복 지급이 발생할 위험이 존재한다.
- 따라서 안정적이고 멱등적인 재시도 전략이 필요하다.

## Decision
- Spring Retry 를 사용하여 재시도 전략을 적용한다.
- 재시도 범위는 개별 유저 단위 저장 로직을 한정한다.
- 트랜잭션 전파는 `REQUIRES_NEW`를 사용해서 개별 실패가 전체 배치에 영향을 주지 않도록 한다.
- 재시도 예외 조건은 일시적 오류만 허용한다. (`PessimisticLockingFailureException`, `QueryTimeoutException`, `TransientDataAccessException`)
- **백오프 전략** : 지수 백오프와 랜덤지터를 사용하였다. (초기에는 400ms -> 2배 증가해서 최대 10초, 랜덤 지터 적용)
  - 많은 스레드와 프로세스가 동시에 재시도할 때 한꺼번에 몰리는 것을 막아주기 위해
- **최대 재시도 횟수**: 5회
- **최종 실패 처리**는 `@Recover`에서 수행하며, 실패 로그 기록 및 후속 조치(예: 실패 테이블 적재, 알림)로 확장 가능하다.
- **멱등성 보장**을 위해 당일 동일 유저·정책 지급 이력이 있는지 사전 조회한다.
- **구현 구조 & AOP 유의**:
    - `BirthdayPointService` → 지급 대상 유저 필터링 및 분기
    - `BirthdayPointRetryService` → `@Retryable` 부여된 개별 지급 처리 (**self-invocation 회피를 위해 별도 빈**)

## Consequences
- 장점
    - 개별 유저 단위로 재시도하여 전체 배치 롤백 방지.
    - `REQUIRES_NEW`로 일부 실패가 전체 배치를 방해하지 않는다.
    - 백오프 전략으로 시스템 과부하 방지.
    - `@Recover`로 최종 실패를 관찰, 추적 가능하다.

- 단점
  - 멱등성 로직이 만약에 불완전하면 중복 지급 위험이 존재한다 -> DB 유니크 제약이 필요할 수도 있다.
  - 재시도 지연으로 일부 지급이 늦어질 수 있다.

- 추후 고려사항
    - 실패 건을 별도 테이블에 적재 하여 수동 또는 별도 재처리로 복구
    - 유저 수 / 처리량 증가 시에는 Spring Batch로 전환 고려
    - 결국 최종 실패시에는 수동으로 복구해야 하므로 실패 했을때 알림 기능 추가 고려